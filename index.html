<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NextGen Terminal 2025</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap');
    :root {
      --primary-color: #2ecc71;
      --background-color: rgba(30, 30, 30, 0.7);
      --text-color: #e0e0e0;
      --header-bg: linear-gradient(90deg, #2a2a2a, #3a3a3a);
      --suggestion-bg: rgba(30, 30, 30, 0.8);
      --tooltip-bg: rgba(30, 30, 30, 0.8);
      --tooltip-color: #d4af37;
      --border-color: rgba(255, 255, 255, 0.2);
      --shadow-color: rgba(0, 0, 0, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'IBM Plex Mono', monospace;
    }

    body {
      background: linear-gradient(135deg, #1a1a1a, #2c2c2c);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    canvas#bgCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
      opacity: 0.2;
    }

    .terminal {
      width: 90%;
      max-width: 850px;
      height: 550px;
      background: var(--background-color);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 8px 32px var(--shadow-color);
      border: 1px solid var(--border-color);
      padding: 24px;
      position: relative;
      z-index: 1;
    }

    .terminal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--header-bg);
      border-radius: 10px 10px 0 0;
      border-bottom: 1px solid var(--border-color);
    }

    .terminal-buttons {
      display: flex;
      gap: 10px;
    }

    .terminal-button {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ff6b6b;
      border: 1px solid rgba(0, 0, 0, 0.3);
      transition: transform 0.2s ease;
    }

    .terminal-button:hover {
      transform: scale(1.2);
    }

    .terminal-button:nth-child(2) { background: #f4c542; }
    .terminal-button:nth-child(3) { background: #2ecc71; }

    .clock-display {
      color: var(--text-color);
      font-size: 13px;
      background: rgba(255, 255, 255, 0.1);
      padding: 4px 8px;
      border-radius: 4px;
    }

    .terminal-body {
      margin-top: 20px;
      height: calc(100% - 50px);
      overflow-y: auto;
      padding: 20px;
      color: var(--text-color);
      font-size: 15px;
      line-height: 1.6;
    }

    .terminal-input {
      display: flex;
      align-items: center;
      margin-top: 12px;
      position: sticky;
      bottom: 0;
      background: inherit;
    }

    .prompt {
      color: var(--primary-color);
      margin-right: 8px;
      font-weight: 600;
    }

    #terminalInput {
      background: transparent;
      border: none;
      color: var(--text-color);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 15px;
      width: 100%;
      outline: none;
    }

    .cursor {
      width: 10px;
      height: 18px;
      background: var(--primary-color);
      display: inline-block;
      animation: blink 1.2s infinite;
    }

    .output {
      margin: 12px 0;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .error {
      color: #ff4d4d;
      font-weight: 600;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 20px;
      background: var(--suggestion-bg);
      backdrop-filter: blur(8px);
      color: var(--text-color);
      border-radius: 6px;
      padding: 8px;
      max-height: 120px;
      overflow-y: auto;
      width: calc(100% - 40px);
      z-index: 2;
      opacity: 0;
      border: 1px solid var(--border-color);
    }

    .suggestion-item {
      padding: 6px 8px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .suggestion-item:hover, .suggestion-item:focus {
      background: rgba(255, 255, 255, 0.1);
    }

    .hint-tooltip {
      position: absolute;
      top: calc(100% + 140px);
      left: 20px;
      background: var(--tooltip-bg);
      color: var(--tooltip-color);
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 4px;
      max-width: calc(100% - 40px);
      z-index: 2;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .terminal-body::-webkit-scrollbar {
      width: 8px;
      background: rgba(0, 0, 0, 0.2);
    }

    .terminal-body::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border: none;
      border-radius: 4px;
    }

    .suggestions::-webkit-scrollbar {
      width: 6px;
      background: rgba(0, 0, 0, 0.2);
    }

    .suggestions::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border: none;
      border-radius: 3px;
    }

    .light-theme {
      --primary-color: #007bff;
      --background-color: rgba(240, 240, 240, 0.9);
      --text-color: #1a1a1a;
      --header-bg: linear-gradient(90deg, #e0e0e0, #f0f0f0);
      --suggestion-bg: rgba(240, 240, 240, 0.9);
      --tooltip-bg: rgba(240, 240, 240, 0.9);
      --tooltip-color: #007bff;
      --border-color: rgba(0, 0, 0, 0.1);
      --shadow-color: rgba(0, 0, 0, 0.2);
    }

    .gold-theme {
      --primary-color: #d4af37;
      --background-color: rgba(30, 30, 30, 0.7);
      --text-color: #d4af37;
      --header-bg: linear-gradient(90deg, #3a3a2a, #4a4a2a);
      --suggestion-bg: rgba(30, 30, 30, 0.8);
      --tooltip-bg: rgba(30, 30, 30, 0.8);
      --tooltip-color: #d4af37;
      --border-color: rgba(212, 175, 55, 0.2);
      --shadow-color: rgba(212, 175, 55, 0.3);
    }

    .silver-theme {
      --primary-color: #c0c0c0;
      --background-color: rgba(30, 30, 30, 0.7);
      --text-color: #c0c0c0;
      --header-bg: linear-gradient(90deg, #2a2a3a, #3a3a4a);
      --suggestion-bg: rgba(30, 30, 30, 0.8);
      --tooltip-bg: rgba(30, 30, 30, 0.8);
      --tooltip-color: #c0c0c0;
      --border-color: rgba(192, 192, 192, 0.2);
      --shadow-color: rgba(192, 192, 192, 0.3);
    }

    @media (max-width: 600px) {
      .terminal {
        width: 95%;
        height: 80vh;
      }
      .terminal-body {
        font-size: 14px;
      }
      .suggestions, .hint-tooltip {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>
  <div class="terminal" role="region" aria-label="NextGen Terminal">
    <div class="terminal-header">
      <div class="terminal-buttons">
        <div class="terminal-button" aria-label="Close"></div>
        <div class="terminal-button" aria-label="Minimize"></div>
        <div class="terminal-button" aria-label="Maximize"></div>
      </div>
      <span class="clock-display" id="clockDisplay"></span>
    </div>
    <div class="terminal-body" id="terminalBody" role="log" aria-live="polite">
      <div class="output">Welcome to NextGen Terminal 2025</div>
      <div class="output">Type 'help' for commands.</div>
      <div class="terminal-input">
        <span class="prompt">$</span>
        <input type="text" id="terminalInput" autocomplete="off" aria-label="Command input">
        <span class="cursor"></span>
        <div class="suggestions" id="suggestions" role="listbox"></div>
        <div class="hint-tooltip" id="hintTooltip" role="tooltip"></div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <script>
    // Three.js Background
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const particleCount = isMobile ? 100 : 400; // Dynamic particle count
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bgCanvas'), alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    for (let i = 0; i < particleCount; i++) {
      vertices.push(
        Math.random() * 120 - 60,
        Math.random() * 120 - 60,
        Math.random() * 120 - 60
      );
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    const material = new THREE.PointsMaterial({ color: 0xe0e0e0, size: 0.3 });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
    camera.position.z = 70;

    let vizObjects = [];
    let vizPersistent = false; // Flag for persistent visualizations
    const animationSpeed = isMobile ? 0.0002 : 0.0004; // Slower animation on mobile

    function clearViz() {
      if (!vizPersistent) {
        vizObjects.forEach(obj => scene.remove(obj));
        vizObjects = [];
      }
    }

    function renderWeatherViz(city) {
      clearViz();
      const globe = new THREE.Mesh(
        new THREE.SphereGeometry(8, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xd4af37, wireframe: true })
      );
      scene.add(globe);
      vizObjects.push(globe);
      const cloudGeometry = new THREE.BufferGeometry();
      const cloudVertices = [];
      for (let i = 0; i < 30; i++) {
        cloudVertices.push(
          Math.random() * 16 - 8,
          Math.random() * 16 - 8,
          Math.random() * 16 - 8
        );
      }
      cloudGeometry.setAttribute('position', new THREE.Float32BufferAttribute(cloudVertices, 3));
      const cloudMaterial = new THREE.PointsMaterial({ color: 0xe0e0e0, size: 0.35 });
      const clouds = new THREE.Points(cloudGeometry, cloudMaterial);
      scene.add(clouds);
      vizObjects.push(clouds);
      gsap.to(globe.rotation, { y: Math.PI * 2, duration: 12, repeat: -1, ease: 'linear' });
      // Removed setTimeout(clearViz, 6000)
    }

    function renderStockViz(symbol, price) {
      clearViz();
      const canvas = document.createElement('canvas');
      canvas.width = 300;
      canvas.height = 150;
      const ctx = canvas.getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: Array(10).fill().map((_, i) => i),
          datasets: [{
            data: Array(10).fill().map(() => price + (Math.random() - 0.5) * 10),
            borderColor: '#d4af37',
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.4
          }]
        },
        options: { scales: { x: { display: false }, y: { display: false } }, plugins: { legend: { display: false } } }
      });
      const texture = new THREE.CanvasTexture(canvas);
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(15, 7.5),
        new THREE.MeshBasicMaterial({ map: texture, transparent: true })
      );
      plane.position.z = 10;
      scene.add(plane);
      vizObjects.push(plane);
      gsap.to(plane.rotation, { y: Math.PI, duration: 10, repeat: -1, ease: 'power2.inOut' });
      // Removed setTimeout(clearViz, 6000)
    }

    function renderDateViz() {
      clearViz();
      const clock = new THREE.Mesh(
        new THREE.CircleGeometry(8, 32),
        new THREE.MeshBasicMaterial({ color: 0xd4af37, wireframe: true })
      );
      scene.add(clock);
      vizObjects.push(clock);
      const hourHand = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 4, 0.1),
        new THREE.MeshBasicMaterial({ color: 0xe0e0e0 })
      );
      hourHand.position.y = 2;
      scene.add(hourHand);
      vizObjects.push(hourHand);
      const now = new Date();
      const hours = now.getHours() % 12;
      const minutes = now.getMinutes();
      gsap.to(hourHand.rotation, { z: -(hours + minutes / 60) * Math.PI / 6, duration: 1.2, ease: 'power2.out' });
      // Removed setTimeout(clearViz, 6000)
    }

    function renderStarsAnimation() {
      clearViz();
      const starGeometry = new THREE.BufferGeometry();
      const starVertices = [];
      for (let i = 0; i < 100; i++) {
        starVertices.push(
          Math.random() * 40 - 20,
          Math.random() * 40 - 20,
          Math.random() * 40 - 20
        );
      }
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xe0e0e0, size: 0.5 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      vizObjects.push(stars);
      // Removed setTimeout(clearViz, 6000)
    }

    function renderTreeViz() {
      clearViz();
      const root = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({ color: 0xd4af37, wireframe: true })
      );
      scene.add(root);
      vizObjects.push(root);
      let yOffset = 2;
      function addNode(dir, parent, x, z, depth) {
        Object.keys(dir.dirs).forEach((name, i) => {
          const node = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.MeshBasicMaterial({ color: 0xe0e0e0, wireframe: true })
          );
          node.position.set(x + (i - Object.keys(dir.dirs).length / 2) * 2, yOffset - depth * 2, z + 2);
          scene.add(node);
          vizObjects.push(node);
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(parent.position.x, parent.position.y, parent.position.z),
            new THREE.Vector3(node.position.x, node.position.y, node.position.z)
          ]);
          const line = new THREE.Line(
            lineGeometry,
            new THREE.LineBasicMaterial({ color: 0x2ecc71 })
          );
          scene.add(line);
          vizObjects.push(line);
          addNode(dir.dirs[name], node, node.position.x, node.position.z, depth + 1);
        });
      }
      addNode(filesystem, root, 0, 0, 1);
      gsap.to(root.rotation, { y: Math.PI * 2, duration: 12, repeat: -1, ease: 'linear' });
      // Removed setTimeout(clearViz, 6000)
    }

    let animationFrameId;
    function animateParticlesLoop() {
      if (!document.hidden) {
        particles.rotation.y += animationSpeed;
        vizObjects.forEach(obj => {
          if (obj.type === 'Points') obj.rotation.y += animationSpeed;
        });
        renderer.render(scene, camera);
      }
      animationFrameId = requestAnimationFrame(animateParticlesLoop);
    }
    animateParticlesLoop();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      if (window.innerHeight < 500) {
        document.querySelector('.terminal').style.height = '60vh';
      } else {
        document.querySelector('.terminal').style.height = '550px';
      }
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animationFrameId);
      } else {
        animateParticlesLoop();
      }
    });

    // Terminal Logic
    const terminalBody = document.getElementById('terminalBody');
    let terminalInput = document.getElementById('terminalInput');
    const suggestions = document.getElementById('suggestions');
    const hintTooltip = document.getElementById('hintTooltip');
    let commandHistory = JSON.parse(localStorage.getItem('commandHistory') || '[]');
    let aliases = JSON.parse(localStorage.getItem('aliases') || '{}');
    let filesystem = JSON.parse(localStorage.getItem('filesystem') || '{"home": {"files": {}, "dirs": {}, "parentPath": null}}');
    let currentDir = filesystem.home;
    let currentDirPath = ['home'];
    let undoStack = [];
    let currentTheme = 'default';
    let currentTimeZone = 'Asia/Kolkata';

    // Filesystem Parent Reconstruction
    function rebuildFilesystemParents(fs) {
      function traverse(dir, path = ['home']) {
        dir.parentPath = path.slice(0, -1);
        dir.parent = null;
        if (dir.parentPath.length) {
          let parent = fs;
          for (let segment of dir.parentPath) {
            parent = parent.dirs[segment];
          }
          dir.parent = parent;
        }
        Object.keys(dir.dirs).forEach(name => {
          traverse(dir.dirs[name], [...path, name]);
        });
      }
      traverse(fs.home);
      return fs;
    }

    // Prepare Filesystem for Serialization
    function prepareFilesystemForSerialization(fs) {
      function traverse(dir) {
        const newDir = { files: { ...dir.files }, dirs: {}, parentPath: dir.parentPath };
        delete newDir.parent;
        Object.keys(dir.dirs).forEach(name => {
          newDir.dirs[name] = traverse(dir.dirs[name]);
        });
        return newDir;
      }
      return { home: traverse(fs.home) };
    }

    // Initialize Filesystem
    filesystem = rebuildFilesystemParents(filesystem);
    currentDir = filesystem.home;

    // Clock Widget
    const clockDisplay = document.getElementById('clockDisplay');
    function updateClock() {
      const now = new Date().toLocaleString('en-US', { timeZone: currentTimeZone, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      clockDisplay.textContent = `${currentDirPath.join('/')}> ${now} (${currentTimeZone})`;
    }
    updateClock();
    setInterval(updateClock, 1000); // Updated to 1-second interval

    // Trie for Autocomplete
    const trie = {
      children: {},
      isEnd: false,
      insert(word) {
        let node = this;
        for (let char of word) {
          if (!node.children[char]) node.children[char] = { children: {}, isEnd: false };
          node = node.children[char];
        }
        node.isEnd = true;
      },
      getSuggestions(prefix) {
        let node = this;
        for (let char of prefix) {
          if (!node.children[char]) return [];
          node = node.children[char];
        }
        return this.collectWords(node, prefix);
      },
      collectWords(node, prefix, words = []) {
        if (node.isEnd) words.push(prefix);
        for (let char in node.children) {
          this.collectWords(node.children[char], prefix + char, words);
        }
        return words;
      }
    };

    // Command Descriptions for Hints
    const commandDescriptions = {
      help: 'Lists all available commands',
      whoami: 'Displays user info',
      about: 'About this terminal',
      clear: 'Clears the terminal',
      date: 'Shows current date with visualization',
      theme: 'Changes theme (default/light/gold/silver)',
      art: 'Displays ASCII art (e.g., art rocket)',
      weather: 'Fetches weather data (e.g., weather Tokyo)',
      stock: 'Fetches stock price (e.g., stock AAPL)',
      liststocks: 'Lists popular stock symbols',
      animate: 'Starts starfield animation (e.g., animate stars)',
      history: 'Shows command history (optional: history <search>)',
      alias: 'Sets a command alias (e.g., alias w=weather)',
      unalias: 'Removes an alias (e.g., unalias w)',
      clock: 'Sets clock timezone (e.g., clock America/New_York)',
      undo: 'Reverts the last command’s output or action',
      export: 'Exports settings to a JSON file',
      import: 'Imports settings from a JSON file',
      mkdir: 'Creates a folder (e.g., mkdir docs)',
      ls: 'Lists files and folders in current directory',
      cd: 'Changes directory (e.g., cd docs, cd ..)',
      rmdir: 'Removes an empty folder (e.g., rmdir docs)',
      tree: 'Visualizes filesystem as a 3D tree',
      touch: 'Creates a file (e.g., touch example.txt)', // Added
      cat: 'Views file contents (e.g., cat example.txt)', // Added
      viz: 'Controls visualizations (e.g., viz on/off/clear)' // Added
    };

    // Commands
    const commands = {
      help: () => `Available commands:
  alias <name>=<command> - Set a command alias
  unalias <name> - Remove an alias
  whoami - Display user info
  about - About this terminal
  clear - Clear the terminal
  date - Show current date
  theme default/light/gold/silver - Change theme
  art rocket - Display rocket ASCII art
  weather <city> - Fetch weather data
  stock <symbol> - Fetch stock price (e.g., stock AAPL)
  liststocks - List popular stock symbols
  animate stars - Start starfield animation
  history [search] - Show command history
  clock <timezone> - Set clock timezone
  undo - Revert last command
  export - Export settings
  import - Import settings
  mkdir <folder> - Create a folder
  ls - List files and folders
  cd <folder> - Change directory
  rmdir <folder> - Remove an empty folder
  tree - Visualize filesystem as 3D tree
  touch <filename> - Create a file
  cat <filename> - View file contents
  viz on/off/clear - Control visualizations`,
      whoami: () => 'user@nextgen2025',
      about: () => 'NextGen Terminal 2025: A sleek CLI with 3D visualizations, aliases, and filesystem. Created by Yash Nigam.',
      clear: () => {
        const action = { type: 'clear', outputs: Array.from(terminalBody.querySelectorAll('.output')) };
        undoStack.push(action);
        terminalBody.innerHTML = `<div class="terminal-input">
          <span class="prompt">$</span>
          <input type="text" id="terminalInput" autocomplete="off" aria-label="Command input">
          <span class="cursor"></span>
          <div class="suggestions" id="suggestions" role="listbox"></div>
          <div class="hint-tooltip" id="hintTooltip" role="tooltip"></div>
        </div>`;
        terminalInput = document.getElementById('terminalInput');
        hintTooltip.remove();
        terminalBody.querySelector('.terminal-input').appendChild(hintTooltip);
        setInputListener();
        terminalInput.focus();
        terminalInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        clearViz();
        return '';
      },
      date: () => {
        renderDateViz();
        const result = new Date().toLocaleString('en-US', { timeZone: currentTimeZone });
        undoStack.push({ type: 'output', element: null });
        return result;
      },
      theme: (arg) => {
        const terminal = document.querySelector('.terminal');
        const prevTheme = currentTheme;
        terminal.classList.remove('light-theme', 'gold-theme', 'silver-theme');
        if (arg === 'light') {
          terminal.classList.add('light-theme');
          material.color.set(0x007bff);
          currentTheme = 'light';
          undoStack.push({ type: 'theme', prevTheme });
          return 'Light theme applied.';
        } else if (arg === 'gold') {
          terminal.classList.add('gold-theme');
          material.color.set(0xd4af37);
          currentTheme = 'gold';
          undoStack.push({ type: 'theme', prevTheme });
          return 'Gold theme applied.';
        } else if (arg === 'silver') {
          terminal.classList.add('silver-theme');
          material.color.set(0xc0c0c0);
          currentTheme = 'silver';
          undoStack.push({ type: 'theme', prevTheme });
          return 'Silver theme applied.';
        } else if (arg === 'default') {
          material.color.set(0xe0e0e0);
          currentTheme = 'default';
          undoStack.push({ type: 'theme', prevTheme });
          return 'Default theme applied.';
        }
        return 'Usage: theme default/light/gold/silver';
      },
      art: (arg) => {
        const result = arg === 'rocket' ? `
        ^  ^
       / 0  \\
      ( ===  )
       '---' ` : 'Unknown art. Try "art rocket".';
        undoStack.push({ type: 'output', element: null });
        return result;
      },
      weather: async (city) => {
        if (!city) return 'Please provide a city name.';
        try {
          // Updated mock data (placeholder for real API)
          const data = { weather: [{ description: 'partly cloudy' }], main: { temp: 22.5, humidity: 65 } };
          renderWeatherViz(city);
          const result = `Weather in ${city}: ${data.weather[0].description}, ${Math.round(data.main.temp)}°C, Humidity: ${data.main.humidity}%`;
          undoStack.push({ type: 'output', element: null });
          return result;
          // Placeholder for real API integration
          // const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${localStorage.getItem('weatherApiKey')}&units=metric`);
          // const data = await response.json();
          // if (data.cod !== 200) return `Error: ${data.message}`;
        } catch (e) {
          return 'Error fetching weather data.';
        }
      },
      stock: async (symbol) => {
        if (!symbol) return 'Please provide a stock symbol (e.g., "stock AAPL").';
        if (symbol.toLowerCase() === 'google') return `Did you mean "GOOGL"? Try "stock GOOGL".`;
        try {
          // Updated mock data (placeholder for real API)
          const data = { 'Global Quote': { '01. symbol': symbol, '05. price': '152.75', '09. change': '2.25', '10. change percent': '1.50%' } };
          if (data['Error Message']) return `Invalid stock symbol (e.g., "AAPL").`;
          const quote = data['Global Quote'];
          if (!quote || !quote['01. symbol']) return `No data for ${symbol}. Try a valid symbol.`;
          renderStockViz(symbol, parseFloat(quote['05. price']));
          const result = `Stock ${quote['01. symbol']}: $${parseFloat(quote['05. price']).toFixed(2)}, Change: ${parseFloat(quote['09. change']).toFixed(2)} (${quote['10. change percent']})`;
          undoStack.push({ type: 'output', element: null });
          return result;
          // Placeholder for real API integration
          // const response = await fetch(`https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${localStorage.getItem('stockApiKey')}`);
          // const data = await response.json();
        } catch (e) {
          return 'Error fetching stock data.';
        }
      },
      liststocks: async () => {
        try {
          // Updated mock data
          const text = 'AAPL,Apple Inc.\nMSFT,Microsoft Corp.\nGOOGL,Alphabet Inc.\nAMZN,Amazon.com Inc.';
          const lines = text.split('\n').slice(0, 10);
          if (!lines.length) return 'No stock data available.';
          const stocks = lines.map(line => {
            const [symbol, name] = line.split(',').slice(0, 2);
            return `${symbol}: ${name}`;
          });
          const result = `Popular Stocks (Top 10):\n${stocks.join('\n')}`;
          undoStack.push({ type: 'output', element: null });
          return result;
        } catch (e) {
          return 'Error fetching stock list.';
        }
      },
      animate: (arg) => {
        if (arg === 'stars') {
          renderStarsAnimation();
          const result = 'Starfield animation started.';
          undoStack.push({ type: 'output', element: null });
          return result;
        }
        return 'Usage: animate stars';
      },
      history: (arg) => {
        if (!arg) {
          const result = commandHistory.length ? `Command history:\n${commandHistory.join('\n')}` : 'No command history.';
          undoStack.push({ type: 'output', element: null });
          return result;
        }
        const filtered = commandHistory.filter(cmd => cmd.toLowerCase().includes(arg.toLowerCase()));
        const result = filtered.length ? `Filtered history:\n${filtered.join('\n')}` : 'No matching commands found.';
        undoStack.push({ type: 'output', element: null });
        return result;
      },
      alias: (arg) => {
        if (!arg || !arg.includes('=')) return 'Usage: alias <name>=<command>';
        const [name, command] = arg.split('=').map(s => s.trim());
        if (!name || !command) return 'Invalid alias format. Use: alias <name>=<command>';
        if (commands[name] || aliases[name]) return `Alias or command '${name}' already exists.`;
        aliases[name] = command;
        trie.insert(name);
        localStorage.setItem('aliases', JSON.stringify(aliases));
        undoStack.push({ type: 'alias', name });
        return `Alias '${name}' set to '${command}'.`;
      },
      unalias: (name) => {
        if (!name) return 'Usage: unalias <name>';
        if (!aliases[name]) return `Alias '${name}' not found.`;
        const removedAlias = aliases[name];
        delete aliases[name];
        localStorage.setItem('aliases', JSON.stringify(aliases));
        trie.children = {};
        Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
        Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
        undoStack.push({ type: 'unalias', name, command: removedAlias });
        return `Alias '${name}' removed.`;
      },
      clock: (timezone) => {
        if (!timezone) return 'Usage: clock <timezone> (e.g., clock America/New_York)';
        try {
          const prevTimeZone = currentTimeZone;
          new Date().toLocaleString('en-US', { timeZone: timezone });
          currentTimeZone = timezone;
          updateClock();
          undoStack.push({ type: 'clock', prevTimeZone });
          return `Clock timezone set to ${timezone}.`;
        } catch (e) {
          return `Invalid timezone: ${timezone}.`;
        }
      },
      undo: () => {
        if (!undoStack.length) return 'Nothing to undo.';
        const action = undoStack.pop();
        if (action.type === 'output') {
          const lastOutput = terminalBody.querySelector('.output:last-of-type:not(.error)');
          if (lastOutput) lastOutput.remove();
          return 'Last output removed.';
        } else if (action.type === 'clear') {
          terminalBody.innerHTML = '';
          action.outputs.forEach(output => terminalBody.appendChild(output));
          terminalBody.innerHTML += `<div class="terminal-input">
            <span class="prompt">$</span>
            <input type="text" id="terminalInput" autocomplete="off" aria-label="Command input">
            <span class="cursor"></span>
            <div class="suggestions" id="suggestions" role="listbox"></div>
            <div class="hint-tooltip" id="hintTooltip" role="tooltip"></div>
          </div>`;
          terminalInput = document.getElementById('terminalInput');
          hintTooltip.remove();
          terminalBody.querySelector('.terminal-input').appendChild(hintTooltip);
          setInputListener();
          terminalInput.focus();
          return 'Terminal clear undone.';
        } else if (action.type === 'theme') {
          const terminal = document.querySelector('.terminal');
          terminal.classList.remove('light-theme', 'gold-theme', 'silver-theme');
          if (action.prevTheme === 'light') terminal.classList.add('light-theme');
          else if (action.prevTheme === 'gold') terminal.classList.add('gold-theme');
          else if (action.prevTheme === 'silver') terminal.classList.add('silver-theme');
          material.color.set(action.prevTheme === 'light' ? 0x007bff : action.prevTheme === 'gold' ? 0xd4af37 : action.prevTheme === 'silver' ? 0xc0c0c0 : 0xe0e0e0);
          currentTheme = action.prevTheme;
          return `Theme reverted to ${action.prevTheme}.`;
        } else if (action.type === 'alias') {
          delete aliases[action.name];
          localStorage.setItem('aliases', JSON.stringify(aliases));
          trie.children = {};
          Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
          Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
          return `Alias '${action.name}' removed.`;
        } else if (action.type === 'unalias') {
          aliases[action.name] = action.command;
          localStorage.setItem('aliases', JSON.stringify(aliases));
          trie.insert(action.name);
          return `Alias '${action.name}' restored.`;
        } else if (action.type === 'clock') {
          currentTimeZone = action.prevTimeZone;
          updateClock();
          return `Clock timezone reverted to ${action.prevTimeZone}.`;
        } else if (action.type === 'mkdir') {
          delete currentDir.dirs[action.folder];
          localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
          trie.children = {};
          Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
          Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
          return `Folder '${action.folder}' removed.`;
        } else if (action.type === 'rmdir') {
          currentDir.dirs[action.folder] = { files: {}, dirs: {}, parentPath: currentDirPath.slice() };
          localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
          trie.insert(action.folder);
          return `Folder '${action.folder}' restored.`;
        } else if (action.type === 'cd') {
          currentDir = action.prevDir;
          currentDirPath = action.prevPath;
          localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
          trie.children = {};
          Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
          Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
          updateClock();
          return `Changed to ${currentDirPath.join('/')}`;
        } else if (action.type === 'touch') {
          delete currentDir.files[action.filename];
          localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
          trie.children = {};
          Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
          Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
          return `File '${action.filename}' removed.`;
        }
        return 'Undo not supported for this action.';
      },
      export: () => {
        const settings = {
          commandHistory,
          aliases,
          theme: currentTheme,
          timeZone: currentTimeZone,
          filesystem: prepareFilesystemForSerialization(filesystem)
        };
        const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'terminal-settings.json';
        a.click();
        URL.revokeObjectURL(url);
        undoStack.push({ type: 'output', element: null });
        return 'Settings exported to terminal-settings.json.';
      },
      import: () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const settings = JSON.parse(event.target.result);
              if (settings.commandHistory) {
                commandHistory = settings.commandHistory.slice(0, 50);
                localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
                historyIndex = commandHistory.length;
              }
              if (settings.aliases) {
                aliases = settings.aliases;
                localStorage.setItem('aliases', JSON.stringify(aliases));
              }
              if (settings.theme) {
                const terminal = document.querySelector('.terminal');
                terminal.classList.remove('light-theme', 'gold-theme', 'silver-theme');
                if (settings.theme === 'light') terminal.classList.add('light-theme');
                else if (settings.theme === 'gold') terminal.classList.add('gold-theme');
                else if (settings.theme === 'silver') terminal.classList.add('silver-theme');
                material.color.set(settings.theme === 'light' ? 0x007bff : settings.theme === 'gold' ? 0xd4af37 : settings.theme === 'silver' ? 0xc0c0c0 : 0xe0e0e0);
                currentTheme = settings.theme;
              }
              if (settings.timeZone) {
                currentTimeZone = settings.timeZone;
                updateClock();
              }
              if (settings.filesystem) {
                filesystem = rebuildFilesystemParents(settings.filesystem);
                currentDir = filesystem.home;
                currentDirPath = ['home'];
                localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
              }
              trie.children = {};
              Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
              Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
              handleCommandOutput('Settings imported successfully.');
            } catch (e) {
              handleCommandOutput('Error: Invalid settings file.', true);
            }
          };
          reader.readAsText(file);
        };
        input.click();
        return '';
      },
      mkdir: (folder) => {
        if (!folder) return 'Usage: mkdir <folder>';
        if (currentDir.dirs[folder] || currentDir.files[folder]) return `Folder or file '${folder}' already exists.`;
        currentDir.dirs[folder] = { files: {}, dirs: {}, parentPath: currentDirPath.slice() };
        currentDir.dirs[folder].parent = currentDir;
        localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
        trie.insert(folder);
        undoStack.push({ type: 'mkdir', folder });
        return `Created folder '${folder}'.`;
      },
      ls: () => {
        const items = Object.keys(currentDir.files).concat(Object.keys(currentDir.dirs));
        const result = items.length ? items.join('\n') : 'Empty directory';
        undoStack.push({ type: 'output', element: null });
        return result;
      },
      cd: (path) => {
        if (!path) return 'Usage: cd <folder> or cd ..';
        if (path === '..') {
          if (!currentDir.parent) return 'Already at root directory.';
          const prevDir = currentDir;
          const prevPath = [...currentDirPath];
          currentDir = currentDir.parent;
          currentDirPath.pop();
          localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
          trie.children = {};
          Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
          Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
          updateClock();
          undoStack.push({ type: 'cd', prevDir, prevPath });
          return `Changed to ${currentDirPath.join('/')}`;
        }
        if (!currentDir.dirs[path]) return `Folder '${path}' not found.`;
        const prevDir = currentDir;
        const prevPath = [...currentDirPath];
        currentDir = currentDir.dirs[path];
        currentDirPath.push(path);
        localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
        trie.children = {};
        Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
        Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
        updateClock();
        undoStack.push({ type: 'cd', prevDir, prevPath });
        return `Changed to ${currentDirPath.join('/')}`;
      },
      rmdir: (folder) => {
        if (!folder) return 'Usage: rmdir <folder>';
        if (!currentDir.dirs[folder]) return `Folder '${folder}' not found.`;
        if (Object.keys(currentDir.dirs[folder].files).length || Object.keys(currentDir.dirs[folder].dirs).length) {
          return `Folder '${folder}' is not empty.`;
        }
        delete currentDir.dirs[folder];
        localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
        trie.children = {};
        Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
        Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));
        undoStack.push({ type: 'rmdir', folder });
        return `Removed folder '${folder}'.`;
      },
      tree: () => {
        renderTreeViz();
        const result = 'Filesystem tree visualized.';
        undoStack.push({ type: 'output', element: null });
        return result;
      },
      touch: (filename) => {
        if (!filename) return 'Usage: touch <filename>';
        if (currentDir.files[filename] || currentDir.dirs[filename]) return `File or folder '${filename}' already exists.`;
        currentDir.files[filename] = { content: '', created: Date.now() };
        localStorage.setItem('filesystem', JSON.stringify(prepareFilesystemForSerialization(filesystem)));
        undoStack.push({ type: 'touch', filename });
        return `Created file '${filename}'.`;
      },
      cat: (filename) => {
        if (!filename) return 'Usage: cat <filename>';
        if (!currentDir.files[filename]) return `File '${filename}' not found.`;
        undoStack.push({ type: 'output', element: null });
        return currentDir.files[filename].content || 'File is empty.';
      },
      viz: (arg) => {
        if (arg === 'on') {
          vizPersistent = true;
          return 'Visualizations set to persistent.';
        } else if (arg === 'off') {
          vizPersistent = false;
          clearViz();
          return 'Visualizations set to temporary.';
        } else if (arg === 'clear') {
          clearViz();
          return 'Visualizations cleared.';
        }
        return 'Usage: viz on/off/clear';
      }
    };

    // Initialize Trie
    Object.keys(commands).concat(Object.keys(aliases)).forEach(cmd => trie.insert(cmd));
    Object.keys(currentDir.dirs).forEach(dir => trie.insert(dir));

    // Handle Command
    function handleCommandOutput(result, isError = false) {
      const outputDiv = document.createElement('div');
      outputDiv.className = `output ${isError ? 'error' : ''}`;
      outputDiv.textContent = result;
      const inputContainer = terminalBody.querySelector('.terminal-input');
      if (!inputContainer) {
        terminalBody.innerHTML = `<div class="output error">Error: Terminal input failed to initialize.</div>`;
        commands.clear();
        return;
      }
      terminalBody.insertBefore(outputDiv, inputContainer);
      gsap.fromTo(outputDiv, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 0.6, ease: 'power2.out' });
      terminalBody.scrollTop = terminalBody.scrollHeight;
    }

    function handleCommand(input) {
      if (!input.trim()) return;
      let [cmd, ...args] = input.toLowerCase().split(' ');
      if (aliases[cmd]) {
        const aliasCommand = aliases[cmd];
        const fullCommand = aliasCommand + (args.length ? ' ' + args.join(' ') : '');
        [cmd, ...args] = fullCommand.toLowerCase().split(' ');
      }
      const commandResult = commands[cmd] ? commands[cmd](args.join(' ')) : `Command not found: ${cmd}`;
      const inputContainer = terminalBody.querySelector('.terminal-input');
      if (!inputContainer) {
        terminalBody.innerHTML = `<div class="output error">Error: Terminal input failed to initialize.</div>`;
        commands.clear();
        return;
      }

      if (commandResult instanceof Promise) {
        handleCommandOutput('Fetching...');
        commandResult.then(result => {
          handleCommandOutput(result, result.includes('Error'));
        }).catch(() => {
          handleCommandOutput('Unexpected error occurred.', true);
        });
      } else if (commandResult !== '') {
        handleCommandOutput(commandResult, commandResult.includes('Error'));
      }

      terminalInput.value = '';
      suggestions.innerHTML = '';
      hintTooltip.innerHTML = '';
      gsap.to(suggestions, { opacity: 0, duration: 0.3 });
      gsap.to(hintTooltip, { opacity: 0, duration: 0.3 });

      commandHistory.push(input);
      if (commandHistory.length > 50) commandHistory.shift();
      localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
      historyIndex = commandHistory.length;
    }

    // Autocomplete Suggestions and Hints
    let debounceTimeout;
    function showSuggestions(input) {
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(() => {
        suggestions.innerHTML = '';
        hintTooltip.innerHTML = '';
        if (input) {
          const matches = trie.getSuggestions(input.toLowerCase()).slice(0, 5);
          if (matches.length) {
            matches.forEach((match, index) => {
              const div = document.createElement('div');
              div.className = 'suggestion-item';
              div.textContent = match;
              div.setAttribute('role', 'option');
              div.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
              div.setAttribute('tabindex', index === 0 ? 0 : -1);
              div.addEventListener('click', () => {
                terminalInput.value = match;
                suggestions.innerHTML = '';
                hintTooltip.innerHTML = '';
                gsap.to(suggestions, { opacity: 0, duration: 0.3 });
                gsap.to(hintTooltip, { opacity: 0, duration: 0.3 });
                terminalInput.focus();
                terminalInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              });
              div.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  terminalInput.value = match;
                  suggestions.innerHTML = '';
                  hintTooltip.innerHTML = '';
                  gsap.to(suggestions, { opacity: 0, duration: 0.3 });
                  gsap.to(hintTooltip, { opacity: 0, duration: 0.3 });
                  terminalInput.focus();
                  terminalInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              });
              suggestions.appendChild(div);
            });
            suggestions.setAttribute('role', 'listbox');
            gsap.fromTo(suggestions, { opacity: 0, y: 5 }, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' });

            // Show hint for the first matching command or folder
            const firstMatch = matches[0];
            if (commandDescriptions[firstMatch] || aliases[firstMatch] || currentDir.dirs[firstMatch]) {
              hintTooltip.textContent = aliases[firstMatch] ? `Alias for: ${aliases[firstMatch]}` : 
                                       currentDir.dirs[firstMatch] ? `Folder: ${firstMatch}` : 
                                       commandDescriptions[firstMatch];
              gsap.fromTo(hintTooltip, { opacity: 0, y: 5 }, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' });
            }
          }
        }
      }, 100);
    }

    // Input Listener
    let historyIndex = commandHistory.length;
    function setInputListener() {
      terminalInput = document.getElementById('terminalInput');
      terminalInput.addEventListener('keydown', (e) => {
        const suggestionItems = suggestions.querySelectorAll('.suggestion-item');
        let focusedIndex = Array.from(suggestionItems).findIndex(item => item.getAttribute('aria-selected') === 'true');
        if (e.key === 'Enter' && terminalInput.value.trim()) {
          handleCommand(terminalInput.value.trim());
        } else if (e.key === 'ArrowUp' && historyIndex > 0) {
          e.preventDefault();
          historyIndex--;
          terminalInput.value = commandHistory[historyIndex] || '';
          showSuggestions(terminalInput.value);
        } else if (e.key === 'ArrowDown' && historyIndex < commandHistory.length - 1) {
          e.preventDefault();
          historyIndex++;
          terminalInput.value = commandHistory[historyIndex] || '';
          showSuggestions(terminalInput.value);
        } else if (e.key === 'Tab' && suggestionItems.length) {
          e.preventDefault();
          terminalInput.value = suggestionItems[0].textContent;
          suggestions.innerHTML = '';
          hintTooltip.innerHTML = '';
          gsap.to(suggestions, { opacity: 0, duration: 0.3 });
          gsap.to(hintTooltip, { opacity: 0, duration: 0.3 });
          terminalInput.focus();
        } else if (e.key === 'ArrowDown' && focusedIndex < suggestionItems.length - 1) {
          e.preventDefault();
          suggestionItems[focusedIndex].setAttribute('aria-selected', 'false');
          suggestionItems[focusedIndex].setAttribute('tabindex', '-1');
          focusedIndex++;
          suggestionItems[focusedIndex].setAttribute('aria-selected', 'true');
          suggestionItems[focusedIndex].setAttribute('tabindex', '0');
          suggestionItems[focusedIndex].focus();
          hintTooltip.innerHTML = '';
          const match = suggestionItems[focusedIndex].textContent;
          if (commandDescriptions[match] || aliases[match] || currentDir.dirs[match]) {
            hintTooltip.textContent = aliases[match] ? `Alias for: ${aliases[match]}` : 
                                     currentDir.dirs[match] ? `Folder: ${match}` : 
                                     commandDescriptions[match];
            gsap.fromTo(hintTooltip, { opacity: 0, y: 5 }, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' });
          }
        } else if (e.key === 'ArrowUp' && focusedIndex > 0) {
          e.preventDefault();
          suggestionItems[focusedIndex].setAttribute('aria-selected', 'false');
          suggestionItems[focusedIndex].setAttribute('tabindex', '-1');
          focusedIndex--;
          suggestionItems[focusedIndex].setAttribute('aria-selected', 'true');
          suggestionItems[focusedIndex].setAttribute('tabindex', '0');
          suggestionItems[focusedIndex].focus();
          hintTooltip.innerHTML = '';
          const match = suggestionItems[focusedIndex].textContent;
          if (commandDescriptions[match] || aliases[match] || currentDir.dirs[match]) {
            hintTooltip.textContent = aliases[match] ? `Alias for: ${aliases[match]}` : 
                                     currentDir.dirs[match] ? `Folder: ${match}` : 
                                     commandDescriptions[match];
            gsap.fromTo(hintTooltip, { opacity: 0, y: 5 }, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' });
          }
        }
      });
      terminalInput.addEventListener('input', () => {
        showSuggestions(terminalInput.value);
      });
      terminalInput.addEventListener('focus', () => {
        terminalInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      });
    }

    // Initialize
    gsap.from('.terminal', { scale: 0.9, opacity: 0, duration: 1.2, ease: 'back.out(1.4)' });
    document.querySelectorAll('.output').forEach((output, index) => {
      gsap.fromTo(output, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 0.6, delay: index * 0.4, ease: 'power2.out' });
    });
    setInputListener();
    terminalInput.setAttribute('aria-live', 'polite');
    terminalInput.focus();
  </script>
</body>
</html>